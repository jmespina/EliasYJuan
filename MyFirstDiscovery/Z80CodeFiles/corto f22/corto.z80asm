

; Put your Z80 assembly code into code files
Start:
; Ejemplo impresion mapa de 16x16 desde array global
ORG     35000

    LD HL, sokoban1_gfx
    LD (DM_SPRITES), HL
    LD HL, sokoban1_attr
    LD (DM_ATTRIBS), HL
    LD HL, mapa_ejemplo
    LD (DM_MAP), HL
    LD HL, mapa_pantalla10x10 ;JM
    LD (DM_MAP10x10), HL     ;JM

    LD A, ANCHO_PANTALLA
    LD (DM_WIDTH), A
    LD A, ALTO_PANTALLA
    LD (DM_HEIGHT), A
    XOR A
    LD (DM_COORD_X), A
    LD (DM_COORD_Y), A
    LD (DM_MAPX), A            ; Establecemos MAPX, MAPY iniciales
    LD (DM_MAPY), A


ld			hl, udgsCommon
ld			(UDG), hl

CALL pintarBicho ; inicializamos

redraw:
    push IY
    CALL DrawMap_16x16_Map     ; Imprimir pantalla de mapa
    pop IY
    ;CALL PINTAR_NAVE            ;MIO
    call DrawSprite_16x16_LD ; pintamos el bicho moviendose
    ;push iy
    call ImpMap10x10 ; Imprimimos el mapa 10x10
    ;pop iy

bucle:
    CALL LEER_TECLADO          ; Leemos el estado de O, P, Q, A

    

    BIT 0, A                   ; Modificamos MAPX y MAPY segun OPQA
    JR Z, nopulsada_q
    CALL Map_Dec_Y
    JR redraw
nopulsada_q:
    BIT 1, A
    JR Z, nopulsada_a
    CALL Map_Inc_Y
    JR redraw
nopulsada_a:
    BIT 2, A
    JR Z, nopulsada_p
    CALL moverNaveDerecha
;    CALL Map_Inc_X
    JR redraw
nopulsada_p:
    BIT 3, A
    JR Z, nopulsada_o
    CALL moverNaveIzquierda
    ;CALL Map_Dec_X
    JR redraw
nopulsada_o:
    JR bucle

loop:
    JR loop


moverNaveDerecha:
    ld		bc, (shipPos)

    ;ld      a, SHIP_TOP_R + $01 
    ;sub     c ;
    
    ;ret     z ;
    CALL Map_Inc_X
   
    ;dec c ;
    ld		(shipPos), bc
RET

moverNaveIzquierda:
    ld		bc, (shipPos)

    ;ld      a, SHIP_TOP_L + $01
    ;sub     c
    
    ;ret     z
    CALL Map_Dec_X
   
    ;inc c
    ld		(shipPos), bc
RET

SHIP_TOP_L:	EQU $01
SHIP_TOP_R: EQU $10

;-------------------------------------------------------------
; LEER_TECLADO: Lee el estado de O, P, Q, A, y devuelve
; en A el estado de las teclas (1=pulsada, 0=no pulsada).
; El byte está codificado tal que:
;
; BITS            3    2     1   0
; SIGNIFICADO   LEFT RIGHT DOWN  UP
;-------------------------------------------------------------
LEER_TECLADO:
    LD D, 0
    LD BC, $FBFE
    IN A, (C)
    BIT 0, A                   ; Leemos la tecla Q
    JR NZ, Control_no_up       ; No pulsada, no cambiamos nada en D
    SET 0, D                   ; Pulsada, ponemos a 1 el bit 0
Control_no_up:

    LD BC, $FDFE
    IN A, (C)
    BIT 0, A                   ; Leemos la tecla A
    JR NZ, Control_no_down     ; No pulsada, no cambianos nada en D
    SET 1, D                   ; Pulsada, ponemos a 1 el bit 1
Control_no_down:

    LD BC, $DFFE
    IN A, (C)
    BIT 0, A                   ; Leemos la tecla P
    JR NZ, Control_no_right    ; No pulsada
    SET 2, D                   ; Pulsada, ponemos a 1 el bit 2
Control_no_right:
                               ; BC ya vale $DFFE, (O y P en misma fila)
    BIT 1, A                   ; Tecla O
    JR NZ, Control_no_left
    SET 3, D
Control_no_left:
    LD A, D                    ; Devolvemos en A el estado de las teclas
    RET

;-------------------------------------------------------------
; Variables que usaremos como parámetros
;-------------------------------------------------------------
DM_SPRITES  DEFW   0
DM_ATTRIBS  DEFW   0
DM_MAP      DEFW   0
DM_MAP10x10 DEFW   0 ;JM
DM_COORD_X  DEFB   0
DM_COORD_Y  DEFB   0
DM_WIDTH    DEFB   0
DM_HEIGHT   DEFB   0
DM_MAPX     DEFW   0
DM_MAPY     DEFW   0

;-------------------------------------------------------------
; Algunos valores hardcodeados para el ejemplo, en la rutina
; final se puede utilizar DM_WIDTH y DM_HEIGHT.
;-------------------------------------------------------------
;ANCHO_MAPA_TILES       EQU   32
ALTO_MAPA_TILES        EQU   12
ANCHO_MAPA_TILES       EQU   64
;ALTO_MAPA_TILES        EQU   12
ANCHO_PANTALLA         EQU   10
ALTO_PANTALLA          EQU   10
;ALTO_PANTALLA          EQU   06

;;; Rutina de la ROM del Spectrum, en otros sistemas
;;; sustituir por una rutina especifica de multiplicacion
MULT_HL_POR_DE         EQU   $30A9

;---------------------------------------------------------------
; DrawMap_16x16_Map:
; Imprime una pantalla de tiles de 16x16 pixeles.
;
; Entrada (paso por parametros en memoria):
; Direccion             Parametro
; --------------------------------------------------------------
; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.
; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.
; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.
; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.
; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.
; DM_WIDTH   (1 byte)   Ancho del mapa en tiles
; DM_HEIGHT  (1 byte)   Alto del mapa en tiles
; DM_MAPX    (2 bytes)  Coordenada X en mapa.
; DM_MAPY    (2 bytes)  Coordenada Y en mapa.
;---------------------------------------------------------------

DrawMap_16x16_Map:

    LD IX, (DM_MAP)           ; IX apunta al mapa
    LD IY, (DM_MAP10x10)           ; IY apunta al mapa de colisiones

    ;;; NUEVO: Posicionamos el puntero de mapa en posicion inicial.
    LD HL, (DM_MAPY)
    LD DE, ANCHO_MAPA_TILES
    CALL MULT_HL_POR_DE       ; HL = (ANCHO_MAPA * MAPA_Y)
    LD BC, (DM_MAPX)
    ADD HL, BC                ; HL = MAPA_X + (ANCHO_MAPA * MAPA_Y)
    EX DE, HL
    ADD IX, DE                ; IX = Inicio_Mapa + HL
    ;;; FIN NUEVO

    LD A, (DM_HEIGHT)
    LD B, A                   ; B = ALTO_EN_TILES (para bucle altura)

drawmg16_yloop:
    PUSH BC                   ; Guardamos el valor de B

    LD A, (DM_HEIGHT)         ; A = ALTO_EN_TILES
    SUB B                     ; A = ALTO - iteracion_bucle = Y actual
    RLCA                      ; A = Y * 2

    ;;; Calculamos la direccion destino en pantalla como
    ;;; DIR_PANT = DIRECCION(X_INICIAL, Y_INICIAL + Y*2)
    LD BC, (DM_COORD_X)       ; B = DB_COORD_Y y C = DB_COORD_X
    ADD A, B
    LD B, A
    LD A, B
    AND $18
    ADD A, $40
    LD H, A
    LD A, B
    AND 7
    RRCA
    RRCA
    RRCA
    ADD A, C
    LD L, A                   ; HL = DIR_PANTALLA(X_INICIAL,Y_INICIAL+Y*2)

    LD A, (DM_WIDTH)
    LD B, A                   ; B = ANCHO_EN_TILES

drawmg16_xloop:
    PUSH BC                   ; Nos guardamos el contador del bucle

    LD A, (IX+0)              ; Leemos un byte del mapa
    INC IX                    ; Apuntamos al siguiente byte del mapa

    CP 255                    ; Bloque especial a saltar: no se dibuja
    ;CP 0
    JP Z, drawmg16_next

    push AF
    LD A, $08
    LD (IY+0), a  ;JM
    ;INC IY          ;JM
    pop AF

    LD B, A
    EX AF, AF'                ; Nos guardamos una copia del bloque en A'
    LD A, B

    ;;; Calcular posicion origen (array sprites) en HL como:
    ;;;     direccion = base_sprites + (NUM_SPRITE*32)
    EX DE, HL                 ; Intercambiamos DE y HL (DE=destino)
    LD BC, (DM_SPRITES)
    LD L, 0
    SRL A
    RR L
    RRA
    RR L
    RRA
    RR L
    LD H, A
    ADD HL, BC                ; HL = BC + HL = DM_SPRITES + (DM_NUMSPR * 32)
    EX DE, HL                 ; Intercambiamos DE y HL (DE=origen, HL=destino)

    PUSH HL                   ; Guardamos el puntero a pantalla recien calculado
    PUSH HL

    ;;; Impresion de los primeros 2 bloques horizontales del tile

    LD B, 8
drawmg16_loop1:

    LD A, (DE)                ; Bloque 1: Leemos dato del sprite
    LD (HL), A                ; Copiamos dato a pantalla
    INC DE                    ; Incrementar puntero en sprite
    INC L                     ; Incrementar puntero en pantalla
    LD A, (DE)                ; Bloque 2: Leemos dato del sprite
    LD (HL), A                ; Copiamos dato a pantalla
    INC DE                    ; Incrementar puntero en sprite
    INC H                     ; Hay que sumar 256 para ir al siguiente scanline
    DEC L                     ; pero hay que restar el INC L que hicimos.
    DJNZ drawmg16_loop1
    INC L                     ; Decrementar el ultimo incrementado en el bucle

    ; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)
    ; desde el septimo scanline de la fila Y+1 al primero de la Y+2
    LD A, L
    ADD A, 31
    LD L, A
    JR C, drawmg16_nofix_abajop
    LD A, H
    SUB 8
    LD H, A
drawmg16_nofix_abajop:

    ;;; Impresion de los segundos 2 bloques horizontales:
    LD B, 8
drawmg16_loop2:
    LD A, (DE)                ; Bloque 1: Leemos dato del sprite
    LD (HL), A                ; Copiamos dato a pantalla
    INC DE                    ; Incrementar puntero en sprite
    INC L                     ; Incrementar puntero en pantalla
    LD A, (DE)                ; Bloque 2: Leemos dato del sprite
    LD (HL), A                ; Copiamos dato a pantalla
    INC DE                    ; Incrementar puntero en sprite
    INC H                     ; Hay que sumar 256 para ir al siguiente scanline
    DEC L                     ; pero hay que restar el INC L que hicimos.
    DJNZ drawmg16_loop2

    ;;; En este punto, los 16 scanlines del tile estan dibujados.

    ;;;;;; Impresion de la parte de atributos del tile ;;;;;;

    POP HL                    ; Recuperar puntero a inicio de tile

    ;;; Calcular posicion destino en area de atributos en DE.
    LD A, H                   ; Codigo de Get_Attr_Offset_From_Image
    RRCA
    RRCA
    RRCA
    AND 3
    OR $58
    LD D, A
    LD E, L                   ; DE tiene el offset del attr de HL

    LD HL, (DM_ATTRIBS)
    EX AF, AF'                ; Recuperamos el bloque del mapa desde A'
    LD C, A
    LD B, 0
    ADD HL, BC
    ADD HL, BC
    ADD HL, BC
    ADD HL, BC                ; HL = HL+HL=(DM_NUMSPR*4) = Origen de atributo

    LDI
    LDI                       ; Imprimimos la primeras fila de atributos

    ;;; Avance diferencial a la siguiente linea de atributos
    LD A, E                   ; A = E
    ADD A, 30                 ; Sumamos A = A + 30 mas los 2 INCs de LDI.
    LD E, A                   ; Guardamos en E (E = E+30 + 2 por LDI=E+32)
    JR NC, drawmg16_att_noinc
    INC D
drawmg16_att_noinc:
    LDI
    LDI                       ; Imprimimos la segunda fila de atributos

    POP HL                    ; Recuperamos el puntero al inicio

drawmg16_next:
    INC L                     ; Avanzamos al siguiente tile en pantalla
    INC L                     ; horizontalmente
    INC IY  ;JM

    POP BC                    ; Recuperamos el contador para el bucle
    DEC B                     ; DJNZ se sale de rango, hay que usar DEC+JP
    JP NZ, drawmg16_xloop

    ;;; NUEVO: Incrementar puntero de mapa a siguiente linea
    LD BC, ANCHO_MAPA_TILES - ANCHO_PANTALLA
    ADD IX, BC
    ;;; FIN NUEVO

    ;;; En este punto, hemos dibujado ANCHO tiles en pantalla (1 fila)
    POP BC
    DEC B                     ; Bucle vertical
    JP NZ, drawmg16_yloop

    RET

;-------------------------------------------------------------
; Incrementar la variable DM_MAPX para scrollear a la derecha.
;-------------------------------------------------------------

Map_Inc_X:

    halt
    ; mueve al bicho
    push af
    ld a,(DS_COORD_X)
    ld c,a
    ld      a, SHIP_TOP_R + $01 ; Carga en A el tope para la nave por la derecha
    sub     c                   ; Le resta la columna actual de la nave
    JP z, MueveMapaIX                        ; Si es la misma columna, sale
    
    ld a,(DS_COORD_X)  ; como en la resta nos lo cargamos, lo volvemos a carghar
    INC a
    ld (DS_COORD_X), a
    pop af ;habra casos en que no pop y falle
    ret

MueveMapaIX:
    pop af
    LD HL, (DM_MAPX)

    ;;; Comparacion 16 bits de HL y (ANCHO_MAPA-ANCHO_PANTALLA)
    LD A, H
    CP (ANCHO_MAPA_TILES - ANCHO_PANTALLA) / 256
    RET NZ
    LD A, L
    CP (ANCHO_MAPA_TILES - ANCHO_PANTALLA) % 256
    RET Z

    INC HL                     ; No eran iguales, podemos incrementar.
    LD (DM_MAPX), HL

    

    RET


;-------------------------------------------------------------
; Incrementar la variable DM_MAPY para scrollear hacia abajo.
;-------------------------------------------------------------
Map_Inc_Y:
    LD HL, (DM_MAPY)

    ;;; Comparacion 16 bits de HL y (ALTO_MAPA-ALTO_PANTALLA)
    LD A, H
    CP (ALTO_MAPA_TILES-ALTO_PANTALLA) / 256
    RET NZ
    LD A, L
    CP (ALTO_MAPA_TILES-ALTO_PANTALLA) % 256
    RET Z

    INC HL                     ; No eran iguales, podemos incrementar.
    LD (DM_MAPY), HL
    RET

;-------------------------------------------------------------
; Decrementar la variable DM_MAPX para scrollear a la izq.
;-------------------------------------------------------------
Map_Dec_X:
    halt
    ; mueve al bicho
    push af
    ld a,(DS_COORD_X)
    ld c,a
    ld      a, SHIP_TOP_L + $01 ; Carga en A el tope para la nave por la derecha
    sub     c                   ; Le resta la columna actual de la nave
    JP z, MueveMapaDX                        ; Si es la misma columna, sale
    
    ld a,(DS_COORD_X)  ; como en la resta nos lo cargamos, lo volvemos a carghar
    DEC a
    ld (DS_COORD_X), a
    pop af ;habra casos en que no pop y falle
    ret


MueveMapaDX:
    pop af
    LD HL, (DM_MAPX)
    LD A, H
    AND A
    JR NZ, mapdecx_doit        ; Verificamos que DM_MAPX no sea 0
    LD A, L
    AND A
    RET Z
mapdecx_doit:
    DEC HL
    LD (DM_MAPX), HL           ; No es cero, podemos decrementar
    RET

;-------------------------------------------------------------
; Decrementar la variable DM_MAPY para scrollear hacia arriba.
;-------------------------------------------------------------
Map_Dec_Y:
    LD HL, (DM_MAPY)
    LD A, H
    AND A
    JR NZ, mapdecy_doit        ; Verificamos que DM_MAPX no sea 0
    LD A, L
    AND A
    RET Z
mapdecy_doit:
    DEC HL
    LD (DM_MAPY), HL           ; No es cero, podemos decrementar
    RET


PINTAR_NAVE:
    ld		bc, (shipPos)
    ;ld      bc, (DM_MAPX)
    call	At
    ld		a, $90
    rst		$10
    
    ;ld      (hl),c     ;pintara c, la posicion eje X

    LD IX, (DM_MAP10x10) ;JM
    LD C,(IX+0)
    LD (HL),C
    
    ld      bc, $0202
    call    At
    call    PrintBCD
    

    halt
    RET

PrintBCD1d:
push af
ld      a, (hl)     ; Carga en A el número a pintar
and     $f0         ; Se queda con las decenas
rra
rra
rra
rra                 ; Lo pone en los bits 0 a 3
add     a, '0'      ; Le suma el carácter 0
;rst     $10         ; Pinta el dígito

ld      a, (hl)     ; Carga el A el número a pintar
and     $0f         ; Se queda con las unidades
add     a, '0'      ; Le suma el carácter 0
rst     $10         ; Pinta el dígito
pop af

ret


PrintBCD:
ld      a, (hl)     ; Carga en A el número a pintar
and     $f0         ; Se queda con las decenas
rra
rra
rra
rra                 ; Lo pone en los bits 0 a 3
add     a, '0'      ; Le suma el carácter 0
rst     $10         ; Pinta el dígito

ld      a, (hl)     ; Carga el A el número a pintar
and     $0f         ; Se queda con las unidades
add     a, '0'      ; Le suma el carácter 0
rst     $10         ; Pinta el dígito

ret


At:
push	de	; Preserva el valor de DE
push	hl	; Preserva el valor de HL
call	$0a23	; Llama a la rutina de la ROM
pop		hl	; Recupera el valor de HL
pop		de	; Recupera el valor de DE
ret



pintarBicho:
    ld hl, bicho_gfx
    ld (DS_SPRITES), hl
    ld hl, bicho_attrib
    ld (DS_ATTRIBS), hl
    ld a, 2
    ld (DS_COORD_X), a
    ld a, 2
    ld (DS_COORD_Y), a
    xor a
    ld (DS_NUMSPR), a
    call DrawSprite_16x16_LD
ret


bicho_gfx:
	DEFB	  0,224,  7, 16,  8,  8, 11,104
	DEFB	 51,104, 72, 12,137,146,  8, 17
	DEFB	 10, 80,  9,160,  4, 64,  7,192
	DEFB	  4,128,  4,128,  2, 64,  2, 32

bicho_attrib:
	DEFB	 69,  7, 69, 69

DS_SPRITES  DEFW   0
DS_ATTRIBS  DEFW   0
DS_COORD_X  DEFB   0
DS_COORD_Y  DEFB   0
DS_NUMSPR   DEFB   0

;-------------------------------------------------------------
; DrawSprite_16x16_LD:
; Imprime un sprite de 16x16 pixeles con o sin atributos.
;
; Entrada (paso por parametros en memoria):
; Direccion   Parametro
; Direccion        Parametro
; (DS_SPRITES)      Direccion de la tabla de Sprites
; (DS_ATTRIBS)      Direccion de la tabla de Atribs  (0=no atributos)
; (DS_COORD_X)      Coordenada X en baja resolucion
; (DS_COORD_Y)      Coordenada Y en baja resolucion
; (DS_NUMSPR)       Numero de sprite a dibujar (0-N)
;-------------------------------------------------------------
DrawSprite_16x16_LD:
 
    ; Guardamos en BC la pareja (x,y) -> B=COORD_Y y C=COORD_X
    ld bc, (DS_COORD_X) ; lo cambio
 
    ;;; Calculamos las coordenadas destino de pantalla en DE:
    ld a, b
    and $18
    add a, $40
    ld d, a
    ld a, b
    and 7
    rrca
    rrca
    rrca
    add a, c
    ld e, a
 
    push de           ; Lo guardamos para luego, lo usaremos para
                      ; calcular la direccion del atributo
 
    ;;; Calcular posicion origen (array sprites) en HL como:
    ;;;     direccion = base_sprites + (NUM_SPRITE*32)
    ;;; Multiplicamos con desplazamientos, ver los comentarios.
    ld bc, (DS_SPRITES)
    ld a, (DS_NUMSPR)
    ld l, 0           ; AL = DS_NUMSPR*256
    srl a             ; Desplazamos a la derecha para dividir por dos
    rr l              ; AL = DS_NUMSPR*128
    rra               ; Rotamos, ya que el bit que salio de L al CF fue 0
    rr l              ; AL = DS_NUMSPR*64
    rra               ; Rotamos, ya que el bit que salio de L al CF fue 0
    rr l              ; AL = DS_NUMSPR*32
    ld h, a           ; HL = DS_NUMSPR*32
    add hl, bc        ; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 32)
                      ; HL contiene la direccion de inicio en el sprite
 
    ex de, hl         ; Intercambiamos DE y HL (DE=origen, HL=destino)
 
    ;;; Repetir 8 veces (primeros 2 bloques horizontales):
    ld b, 8
 
drawsp16x16_loop1:
    ld a, (de)         ; Bloque 1: Leemos dato del sprite
    ld (hl), a         ; Copiamos dato a pantalla
    inc de             ; Incrementar puntero en sprite
    inc l              ; Incrementar puntero en pantalla
 
    ld a, (de)         ; Bloque 2: Leemos dato del sprite
    ld (hl), a         ; Copiamos dato a pantalla
    inc de             ; Incrementar puntero en sprite
 
    inc h              ; Hay que sumar 256 para ir al siguiente scanline
    dec l              ; pero hay que restar el inc l que hicimos.
    djnz drawsp16x16_loop1
 
    ; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)
    ; desde el septimo scanline de la fila Y+1 al primero de la Y+2
 
    ;;;inc h           ; No hay que hacer inc h, lo hizo en el bucle
    ;;;ld a, h         ; No hay que hacer esta prueba, sabemos que
    ;;;and 7           ; no hay salto (es un cambio de bloque)
    ;;;jr nz, drawsp16_nofix_abajop
    ld a, l
    add a, 32
    ld l, a
    jr c, drawsp16_nofix_abajop
    ld a, h
    sub 8
    ld h, a
 
drawsp16_nofix_abajop:
 
    ;;; Repetir 8 veces (segundos 2 bloques horizontales):
    ld b, 8
 
drawsp16x16_loop2:
    ld a, (de)         ; Bloque 1: Leemos dato del sprite
    ld (hl), a         ; Copiamos dato a pantalla
    inc de             ; Incrementar puntero en sprite
    inc l              ; Incrementar puntero en pantalla
 
    ld a, (de)         ; Bloque 2: Leemos dato del sprite
    ld (hl), a         ; Copiamos dato a pantalla
    inc de             ; Incrementar puntero en sprite
 
    inc h              ; Hay que sumar 256 para ir al siguiente scanline
    dec l              ; pero hay que restar el inc l que hicimos.
    djnz drawsp16x16_loop2
 
    ;;; En este punto, los 16 scanlines del sprite estan dibujados.
 
    pop bc

;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -> ret)
    ld hl, (DS_ATTRIBS)
 
    xor a              ; A = 0
    add a, h           ; A = 0 + H = H
    ret z              ; Si H = 0, volver (no dibujar atributos)
 
    ;;; Calcular posicion destino en area de atributos en DE.
    ld a, b            ; Codigo de Get_Attr_Offset_From_Image
    rrca               ; Obtenemos dir de atributo a partir de
    rrca               ; dir de zona de imagen.
    rrca               ; Nos evita volver a obtener X e Y
    and 3              ; y hacer el calculo completo de la
    or $58             ; direccion en zona de atributos
    ld d, a
    ld e, c            ; DE tiene el offset del attr de HL
 
    ld a, (DS_NUMSPR)  ; Cogemos el numero de sprite a dibujar
    ld c, a
    ld b, 0
    add hl, bc         ; HL = HL+DS_NUMSPR
    add hl, bc         ; HL = HL+DS_NUMSPR*2
    add hl, bc         ; HL = HL+DS_NUMSPR*3
    add hl, bc         ; HL = HL+HL=(DS_NUMSPR*4) = Origen de atributo
 
    ldi
    ldi                ; Imprimimos las 2 primeras filas de atributo
 
    ;;; Avance diferencial a la siguiente linea de atributos
    ld a, e            ; A = L
    add a, 30          ; Sumamos A = A + 30 mas los 2 INCs de ldi.
    ld e, a            ; Guardamos en L (L = L+30 + 2 por ldi=L+32)
    jr nc, drawsp16x16_attrab_noinc
    inc d
drawsp16x16_attrab_noinc:
    ldi
    ldi
    
ret


udgsCommon:
db $24, $42, $99, $bd, $ff, $18, $24, $5a	; $90 Nave

UDG:			EQU $5c7b

shipPos:
;dw $0511    ;centrado
dw $1016   



;-----------------------------------------------------------------------
mapa_ejemplo:
    DEFB 2,7,2,2,7,255,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1
    DEFB 1,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,255,3,255,255,255,255,255,255,255,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,255,255,255,255,255,255,255,255,2,255,2,3,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,255,255,255,255,255,255,255,255,2,255,2,3,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,1,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,7,7,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,4,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,7,7,7,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,5,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,6,5,0,0,0,0,0,0,2,3,2,3,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,4,255,255,255,255,255,255,255,255,0,0,0,0,0,0,6,6,4,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 2,7,2,2,7,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1
    DEFB 1,4,2,3,2,3,0,0,0,0,2,3,2,3,2,3,2,3,4,2,3,2,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    DEFB 1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    
mapa_pantalla10x10:
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    DEFB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


;-----------------------------------------------------------------------
; ASM source file created by SevenuP v1.20
; SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain
; Pixel Size:      ( 16, 128) -   Char Size:       (  2,  16)
; Sort Priorities: X char, Char line, Y char
; Data Outputted:  Gfx / Attr
;-----------------------------------------------------------------------
sokoban1_gfx:
    DEFB   0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0
    DEFB   0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,  0,  0,  0,  0
    DEFB 127,252,193, 86,152,  2,180,170, 173, 86,153,254,194,170,255,254
    DEFB   0,  0,102,102, 51, 50,153,152, 204,204,102,102, 51, 50,  0,  0
    DEFB 127,102,205, 76,151, 24,205, 50, 151,102,205, 76,151, 24,205, 50
    DEFB 131,102,153, 76,173, 24,181, 50, 153,102,195, 76,127, 24,  0,  0
    DEFB 255,252,255,134,255, 50,255, 90, 255,106,255, 50,255,134,255,254
    DEFB 255,254,255,254,255,254,255,250, 255,242,253,166,255,252,  0,  0
    DEFB 127,252,205,134,151, 50,205,106, 151, 90,205, 50,151,134,205,254
    DEFB 195,254,153,254,173,254,181,250, 153,242,195,166,127,252,  0,  0
    DEFB 255,254,255,254,255,254,255,254, 255,254,255,254,191,254,255,254
    DEFB 255,134,191, 50,255,106,191, 90, 159, 50,207,134,127,252,  0,  0
    DEFB   0,  0,127,254, 95,250, 96,  6, 111,182,111,118, 96,230,109,214
    DEFB 107,182,103,  6,110,246,109,246,  96,  6, 95,250,127,254,  0,  0
    DEFB   0,  0,123,222,123,222, 96,  6,  96,  6,  0,  0, 96,  6, 96,  6
    DEFB  96,  6, 96,  6,  0,  0, 96,  6,  96,  6,123,222,123,222,  0,  0

sokoban1_attr:
    DEFB   0,  0,  0,  0,  5,  5, 70, 70, 5, 70,  5, 70, 69, 71, 69, 71
    DEFB   5, 69, 69, 71, 69, 69, 71, 71, 2, 66, 66, 67,  6, 70, 70, 71
ret 


jp #12a2

msg:	defm "Hola ensamblador ZX Spectrum "


; pasmo --name PoromPong --tapbas HolaMundo.asm HolaMundo.tap --public
#include "4ImpMap10x10.z80asm"